"""
    Platform Repository Service

    Platform Repository Service - Sage Bionetworks Platform   # noqa: E501

    The version of the OpenAPI document: develop-SNAPSHOT
    Contact: thomas.yu@sagebionetworks.org
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from synclient.api_client import ApiClient, Endpoint
from synclient.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from synclient.model.challenge import Challenge
from synclient.model.challenge_paged_results import ChallengePagedResults
from synclient.model.challenge_team import ChallengeTeam
from synclient.model.challenge_team_paged_results import ChallengeTeamPagedResults
from synclient.model.paginated_ids import PaginatedIds


class ChallengeServicesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __create_challenge(
            self,
            **kwargs
        ):
            """Create a Challenge object, associated with a Project.  # noqa: E501

            Create a Challenge object, associated with a Project.  A participant Team must be specified.  To create a Challenge one must have CREATE permission on the associated Project.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.create_challenge(async_req=True)
            >>> result = thread.get()


            Keyword Args:
                challenge (Challenge): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                Challenge
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            return self.call_with_http_info(**kwargs)

        self.create_challenge = Endpoint(
            settings={
                'response_type': (Challenge,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge',
                'operation_id': 'create_challenge',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge':
                        (Challenge,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'challenge': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__create_challenge
        )

        def __create_challenge_team(
            self,
            challenge_id,
            **kwargs
        ):
            """Register a Team with a Challenge.  # noqa: E501

            Register a Team with a Challenge. You must be a member of the Challenge's participant Team (i.e. you must be already registered for the Challenge) and be an administrator on the Team being registered.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.create_challenge_team(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                challenge_team (ChallengeTeam): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                ChallengeTeam
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.create_challenge_team = Endpoint(
            settings={
                'response_type': (ChallengeTeam,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/challengeTeam',
                'operation_id': 'create_challenge_team',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'challenge_team',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'challenge_team':
                        (ChallengeTeam,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'challenge_team': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__create_challenge_team
        )

        def __delete_challenge(
            self,
            challenge_id,
            **kwargs
        ):
            """Delete a Challenge.  # noqa: E501

            Delete a Challenge.  The caller must have DELETE permission on the project associated with the Challenge.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.delete_challenge(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                None
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.delete_challenge = Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}',
                'operation_id': 'delete_challenge',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                },
                'location_map': {
                    'challenge_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client,
            callable=__delete_challenge
        )

        def __delete_challenge_team(
            self,
            challenge_team_id,
            **kwargs
        ):
            """De-register a Team from a Challenge.  # noqa: E501

            De-register a Team from a Challenge. You must be a member of the Challenge's participant Team (i.e. you must be already registered for the Challenge) and be an administrator on the Team being de-registered.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.delete_challenge_team(challenge_team_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_team_id (int): The ID of the challenge team.

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                None
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_team_id'] = \
                challenge_team_id
            return self.call_with_http_info(**kwargs)

        self.delete_challenge_team = Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challengeTeam/{challengeTeamId}',
                'operation_id': 'delete_challenge_team',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_team_id',
                ],
                'required': [
                    'challenge_team_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_team_id':
                        (int,),
                },
                'attribute_map': {
                    'challenge_team_id': 'challengeTeamId',
                },
                'location_map': {
                    'challenge_team_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client,
            callable=__delete_challenge_team
        )

        def __get_challenge(
            self,
            challenge_id,
            **kwargs
        ):
            """Retrieve a Challenge given its ID.  # noqa: E501

            Retrieve a Challenge given its ID.  To retrieve a Challenge one must have READ permission on the associated Project.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_challenge(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                Challenge
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.get_challenge = Endpoint(
            settings={
                'response_type': (Challenge,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}',
                'operation_id': 'get_challenge',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                },
                'location_map': {
                    'challenge_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_challenge
        )

        def __get_challenge_by_project_id(
            self,
            id,
            **kwargs
        ):
            """Retrieve a Challenge given the ID of its associated Project.  # noqa: E501

            Retrieve a Challenge given the ID of its associated Project.  To retrieve a Challenge one must have READ permission on the Project.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.get_challenge_by_project_id(id, async_req=True)
            >>> result = thread.get()

            Args:
                id (str): Synapse Project id

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                Challenge
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['id'] = \
                id
            return self.call_with_http_info(**kwargs)

        self.get_challenge_by_project_id = Endpoint(
            settings={
                'response_type': (Challenge,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/entity/{id}/challenge',
                'operation_id': 'get_challenge_by_project_id',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (str,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_challenge_by_project_id
        )

        def __list_challenge_teams(
            self,
            challenge_id,
            **kwargs
        ):
            """List the Teams registered for a Challenge.  # noqa: E501

            List the Teams registered for a Challenge.  You must have READ permission in the associated Project to make this request.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.list_challenge_teams(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                limit (int): Maximum number of results returned. [optional] if omitted the server will use the default value of 10
                offset (int): Index of the first result that must be returned. [optional] if omitted the server will use the default value of 0
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                ChallengeTeamPagedResults
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.list_challenge_teams = Endpoint(
            settings={
                'response_type': (ChallengeTeamPagedResults,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/challengeTeam',
                'operation_id': 'list_challenge_teams',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'limit',
                    'offset',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 10,
                    },
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__list_challenge_teams
        )

        def __list_challenges_for_participant(
            self,
            participant_id,
            **kwargs
        ):
            """List the Challenges for which the given participant is registered.  # noqa: E501

            List the Challenges for which the given participant is registered. To be in the returned list the caller must have READ permission on the project associated with the Challenge.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.list_challenges_for_participant(participant_id, async_req=True)
            >>> result = thread.get()

            Args:
                participant_id (int): Synapse user id

            Keyword Args:
                limit (int): Maximum number of results returned. [optional] if omitted the server will use the default value of 10
                offset (int): Index of the first result that must be returned. [optional] if omitted the server will use the default value of 0
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                ChallengePagedResults
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['participant_id'] = \
                participant_id
            return self.call_with_http_info(**kwargs)

        self.list_challenges_for_participant = Endpoint(
            settings={
                'response_type': (ChallengePagedResults,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge',
                'operation_id': 'list_challenges_for_participant',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'participant_id',
                    'limit',
                    'offset',
                ],
                'required': [
                    'participant_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 10,
                    },
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'participant_id':
                        (int,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'participant_id': 'participantId',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'participant_id': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__list_challenges_for_participant
        )

        def __list_participants_in_challenge(
            self,
            challenge_id,
            **kwargs
        ):
            """List the participants registered for a Challenge.  # noqa: E501

            List the participants registered for a Challenge. The caller must have READ permission on the project associated with the Challenge.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.list_participants_in_challenge(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                affiliated (bool): If affiliated=true, return just participants affiliated with some registered Team.  If false, return those not affiliated with any registered Team. If omitted return all participants. . [optional]
                limit (int): Maximum number of results returned. [optional] if omitted the server will use the default value of 10
                offset (int): Index of the first result that must be returned. [optional] if omitted the server will use the default value of 0
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                PaginatedIds
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.list_participants_in_challenge = Endpoint(
            settings={
                'response_type': (PaginatedIds,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/participant',
                'operation_id': 'list_participants_in_challenge',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'affiliated',
                    'limit',
                    'offset',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 10,
                    },
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'affiliated':
                        (bool,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                    'affiliated': 'affiliated',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'affiliated': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__list_participants_in_challenge
        )

        def __list_registratable_teams(
            self,
            challenge_id,
            **kwargs
        ):
            """List the Teams that caller can register for the Challenge.  # noqa: E501

            List the Teams that caller can register for the Challenge, i.e. Teams on which the caller is an administrator and which are not already registered. The caller must have READ permission on the project associated with the Challenge to make this request.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.list_registratable_teams(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                limit (int): Maximum number of results returned. [optional] if omitted the server will use the default value of 10
                offset (int): Index of the first result that must be returned. [optional] if omitted the server will use the default value of 0
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                PaginatedIds
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.list_registratable_teams = Endpoint(
            settings={
                'response_type': (PaginatedIds,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/registratableTeam',
                'operation_id': 'list_registratable_teams',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'limit',
                    'offset',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 10,
                    },
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__list_registratable_teams
        )

        def __list_submission_teams(
            self,
            challenge_id,
            **kwargs
        ):
            """List the Teams under which the given submitter may submit to the Challenge.  # noqa: E501

            List the Teams under which the given submitter may submit to the Challenge, i.e. the Teams on which the user is a member and which are registered for the Challenge.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.list_submission_teams(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                limit (int): Maximum number of results returned. [optional] if omitted the server will use the default value of 10
                offset (int): Index of the first result that must be returned. [optional] if omitted the server will use the default value of 0
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                PaginatedIds
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.list_submission_teams = Endpoint(
            settings={
                'response_type': (PaginatedIds,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/submissionTeams',
                'operation_id': 'list_submission_teams',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'limit',
                    'offset',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 10,
                    },
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__list_submission_teams
        )

        def __update_challenge(
            self,
            challenge_id,
            **kwargs
        ):
            """Update a Challenge.  # noqa: E501

            Update a Challenge.  The caller must have UPDATE permission on the project associated with the Challenge.  It is not permitted to change the project associated with a Challenge.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.update_challenge(challenge_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.

            Keyword Args:
                challenge (Challenge): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                Challenge
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            return self.call_with_http_info(**kwargs)

        self.update_challenge = Endpoint(
            settings={
                'response_type': (Challenge,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}',
                'operation_id': 'update_challenge',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'challenge',
                ],
                'required': [
                    'challenge_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'challenge':
                        (Challenge,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'challenge': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__update_challenge
        )

        def __update_challenge_team(
            self,
            challenge_id,
            challenge_team_id,
            **kwargs
        ):
            """Update a Challenge Team.  # noqa: E501

            Update a Challenge Team. You must be a member of the Challenge's participant Team (i.e. you must be already registered for the Challenge) and be an administrator on the associated Team.   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.update_challenge_team(challenge_id, challenge_team_id, async_req=True)
            >>> result = thread.get()

            Args:
                challenge_id (int): The ID of the challenge.
                challenge_team_id (int): The ID of the challenge team.

            Keyword Args:
                challenge_team (ChallengeTeam): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                ChallengeTeam
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['challenge_id'] = \
                challenge_id
            kwargs['challenge_team_id'] = \
                challenge_team_id
            return self.call_with_http_info(**kwargs)

        self.update_challenge_team = Endpoint(
            settings={
                'response_type': (ChallengeTeam,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/challenge/{challengeId}/challengeTeam/{challengeTeamId}',
                'operation_id': 'update_challenge_team',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'challenge_id',
                    'challenge_team_id',
                    'challenge_team',
                ],
                'required': [
                    'challenge_id',
                    'challenge_team_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'challenge_id':
                        (int,),
                    'challenge_team_id':
                        (int,),
                    'challenge_team':
                        (ChallengeTeam,),
                },
                'attribute_map': {
                    'challenge_id': 'challengeId',
                    'challenge_team_id': 'challengeTeamId',
                },
                'location_map': {
                    'challenge_id': 'path',
                    'challenge_team_id': 'path',
                    'challenge_team': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__update_challenge_team
        )
